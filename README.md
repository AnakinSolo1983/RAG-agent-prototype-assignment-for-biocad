# RAG-agent-prototype-assignment-for-biocad
Это мое выполнение тестового задания от Biocad для стажировки в машиное обучение. Нужно было создать прототип RAG-агента для помощи исследователям в поиске новых потенциальных мишеней для разработки лекарств от болезни Альцгеймера.

Для этого были собраны последнее научные статьи по следующим темам:
- Alzheimer's disease targets
- Alzheimer therapeutic targets
- Alzheimer drug targets

Решение этого задания состоит из несколько python файлов, которые загружали данные, обработывали их.


## Решение

### Часть 1: Подготовка Данных

Скрипт ```get_data.py``` собирает данные из PubMed, начиная с поиска статей по ключевым словам (темы из условия). Он использует библиотеку Biopython для взаимодействия с базой данных PubMed, извлекает соответствующие статьи и сохраняет результаты в CSV-файл. Используется библиотека Bio.Entrez для поиска и загрузки статей из PubMed.

Скрипт ```clean.py``` обрабатывает текстовые данные из CSV-файла, содержащего статьи PubMed. Скрипт очищает текст, разбивает его на управляемые части и сохраняет результаты в новый CSV-файл.

Скрипт ```get_terms.py``` извлекает биомедицинские термины из текстовых данных. Он использует регулярные выражения для поиска специфических паттернов, которые соответствуют биомедицинским сущностям, и фильтрует их, исключая стоп-слова. Результаты сохраняются в CSV файл для дальнейшего анализа.

Скрипт ```vector.py``` выполняет обработку текстовых данных для создания векторного хранилища (векторы сгенеривованы для каждого предложения) с использованием векторных представлений предложений. Он использует библиотеку SentenceTransformer для преобразования текста в векторы, а также библиотеку FAISS для эффективного хранения этих векторов — создается индекс FAISS, в который добавляются векторы. Наконец, индекс и метаданные сохраняются для дальнейшего использования.

### Часть 2: Реализация RAG системы

Скрипт ```rag.py``` реализует агента RAG. Этот агент сочетает в себе извлекатель и генератор для ответов на вопросы на основе набора документов. Извлекатель получает соответствующие документы из заранее построенного индекса, в то время как генератор формулирует связный ответ на основе извлеченного контекста.

Метод __init__ инициализирует извлекатель, используя модель преобразования предложений, и загружает индекс FAISS для извлечения документов. Он также настраивает модель генерации текста. Метод retrieve кодирует входной запрос в эмбеддинг, ищет в индексе FAISS топ k соответствующих документов и возвращает их. 

Затем метод generate извлекает документы на основе запроса, строит подсказку и генерирует ответ.

### Часть 3: Интерфейс

Реализовать простой интерфейс одним из способов — Streamlit приложение, или Jupyter notebook.

Скрипт ```app.py``` создает интерфейс с использованием библиотеки Streamlit, которое позволяет пользователям вводить исследовательские вопросы о болезни Альцгеймера и получать ответы на основе базы данных, собранной в 1-й части задания. Приложение использует агента RAG из ```rag.py``` для генерации ответа.

После запуска приложения командой 

```
streamlit run app.py
```

пользователь может ввести свой вопрос, и при нажатии кнопки "Run RAG" приложение обрабатывает запрос, генерирует ответ и отображает его вместе с источниками, из которых была получена информация.

А вот ```jupy.ipynb``` создает интерфейс с использованием Jupyter Notebook.

### Часть 4. Вопросы

Кроме создания прототипа RAG агента, нужно было ответить на следующее вопросы:

- На какие модальности данных можно расширить решение?
- Как это можно сделать?
- Какие модели и почему вы выбрали для решения

#### На какие модальности данных можно расширить решение?

Решение сейчас работает только с текстовыми научными статьями в виде текста и эмбеддингов, но решения можно расширить на изображения, например диаграммы или графики. А также такие презентаций данных как таблицы. 

#### Как это можно сделать?

Нужно использовать библиотеки/методы для обработки изображений, таблиц/графов в вектора. 

#### Какие модели и почему вы выбрали для решения

Я ипользую Sentence-Transformer-style эмбеддинги (FAISS индекс) и LLM для генерации ответов, потому что они обеспечивают быстрый поиск по большому количеству документов. Эмбеддинги нужны для эффективного поиска релевантных статей, а LLM для генерации ответа на основе найденных данных. Такой подход используется в RAG-системах и дает хорошие, качественные ответы из больших текстовых файлов.
